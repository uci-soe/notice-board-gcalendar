import React, { useEffect, useState } from 'react';
import PropTypes from 'prop-types';
import './StudentSchedule.css';
import './CalendarNoEvent.css';
import StudentScheduleEvent from './StudentScheduleEvent';
import CalendarNoEvent from './CalendarNoEvent';
import { getDate, getEvents, isTodayTomorrow, MINUTE } from './lib/utils';
const propTypes = {
  range: PropTypes.number,
  limit: PropTypes.number,
  timeMin: PropTypes.instanceOf(Date),
  timeMax: PropTypes.instanceOf(Date),
  children: PropTypes.any,
  noEvent: PropTypes.any
};
const defaultProps = {
  range: 2,
  limit: -1,
  timeMin: getDate(-1),
  timeMax: getDate(1),
  updateTime: MINUTE * 10,
  apiKey: null,
  calendarID: null,
  noEvent: null
};

function StudentSchedule(props) {
  const [events, setEvents] = useState([]);
  useEffect(() => {
    let update;

    const updateFunc = () => {
      getEvents(props.timeMin, props.timeMax, props.calendarID, props.apiKey).then(events => setEvents(events));
      update = setTimeout(() => {
        updateFunc();
      }, props.updateTime);
    };

    updateFunc();
    return () => {
      clearTimeout(update);
    };
  }, [props.timeMin, props.timeMax, props.updateTime, props.calendarID, props.apiKey]);
  const Event = props.children || StudentScheduleEvent;
  const noEvent = props.noEvent || CalendarNoEvent;
  let eventsToday = events.filter(e => isTodayTomorrow(e.start.dateTime));

  if (props.limit >= 0) {
    eventsToday = eventsToday.slice(0, props.limit);
  }

  return React.createElement("div", {
    className: "calendar-events"
  }, eventsToday.length ? eventsToday.map((e, i) => Event(e, i)) : noEvent(true));
}

StudentSchedule.propTypes = propTypes;
StudentSchedule.defaultProps = defaultProps;
export default StudentSchedule;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb21wb25lbnRzL1N0dWRlbnRTY2hlZHVsZS5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiUHJvcFR5cGVzIiwiU3R1ZGVudFNjaGVkdWxlRXZlbnQiLCJDYWxlbmRhck5vRXZlbnQiLCJnZXREYXRlIiwiZ2V0RXZlbnRzIiwiaXNUb2RheVRvbW9ycm93IiwiTUlOVVRFIiwicHJvcFR5cGVzIiwicmFuZ2UiLCJudW1iZXIiLCJsaW1pdCIsInRpbWVNaW4iLCJpbnN0YW5jZU9mIiwiRGF0ZSIsInRpbWVNYXgiLCJjaGlsZHJlbiIsImFueSIsIm5vRXZlbnQiLCJkZWZhdWx0UHJvcHMiLCJ1cGRhdGVUaW1lIiwiYXBpS2V5IiwiY2FsZW5kYXJJRCIsIlN0dWRlbnRTY2hlZHVsZSIsInByb3BzIiwiZXZlbnRzIiwic2V0RXZlbnRzIiwidXBkYXRlIiwidXBkYXRlRnVuYyIsInRoZW4iLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiRXZlbnQiLCJldmVudHNUb2RheSIsImZpbHRlciIsImUiLCJzdGFydCIsImRhdGVUaW1lIiwic2xpY2UiLCJsZW5ndGgiLCJtYXAiLCJpIl0sIm1hcHBpbmdzIjoiQUFBQSxPQUFPQSxLQUFQLElBQWVDLFNBQWYsRUFBMEJDLFFBQTFCLFFBQXlDLE9BQXpDO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUVBLE9BQU8sdUJBQVA7QUFDQSxPQUFPLHVCQUFQO0FBQ0EsT0FBT0Msb0JBQVAsTUFBaUMsd0JBQWpDO0FBQ0EsT0FBT0MsZUFBUCxNQUE0QixtQkFBNUI7QUFDQSxTQUFRQyxPQUFSLEVBQWlCQyxTQUFqQixFQUE0QkMsZUFBNUIsRUFBNkNDLE1BQTdDLFFBQTBELGFBQTFEO0FBRUEsTUFBTUMsU0FBUyxHQUFHO0FBQ2hCQyxFQUFBQSxLQUFLLEVBQUVSLFNBQVMsQ0FBQ1MsTUFERDtBQUVoQkMsRUFBQUEsS0FBSyxFQUFFVixTQUFTLENBQUNTLE1BRkQ7QUFH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Iiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7dXNlRWZmZWN0LCB1c2VTdGF0ZX0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xyXG5cclxuaW1wb3J0ICcuL1N0dWRlbnRTY2hlZHVsZS5jc3MnO1xyXG5pbXBvcnQgJy4vQ2FsZW5kYXJOb0V2ZW50LmNzcyc7XHJcbmltcG9ydCBTdHVkZW50U2NoZWR1bGVFdmVudCBmcm9tICcuL1N0dWRlbnRTY2hlZHVsZUV2ZW50JztcclxuaW1wb3J0IENhbGVuZGFyTm9FdmVudCBmcm9tICcuL0NhbGVuZGFyTm9FdmVudCc7XHJcbmltcG9ydCB7Z2V0RGF0ZSwgZ2V0RXZlbnRzLCBpc1RvZGF5VG9tb3Jyb3csIE1JTlVURX0gZnJvbSAnLi9saWIvdXRpbHMnO1xyXG5cclxuY29uc3QgcHJvcFR5cGVzID0ge1xyXG4gIHJhbmdlOiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gIGxpbWl0OiBQcm9wVHlwZXMubnVtYmVyLFxyXG4gIHRpbWVNaW46IFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpLFxyXG4gIHRpbWVNYXg6IFByb3BUeXBlcy5pbnN0YW5jZU9mKERhdGUpLFxyXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxyXG4gIG5vRXZlbnQ6IFByb3BUeXBlcy5hbnlcclxufTtcclxuXHJcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcclxuICByYW5nZTogMixcclxuICBsaW1pdDogLTEsXHJcbiAgdGltZU1pbjogZ2V0RGF0ZSgtMSksXHJcbiAgdGltZU1heDogZ2V0RGF0ZSgxKSxcclxuICB1cGRhdGVUaW1lOiBNSU5VVEUgKiAxMCxcclxuICBhcGlLZXk6IG51bGwsXHJcbiAgY2FsZW5kYXJJRDogbnVsbCxcclxuICBub0V2ZW50OiBudWxsXHJcbn07XHJcblxyXG5mdW5jdGlvbiBTdHVkZW50U2NoZWR1bGUocHJvcHMpIHtcclxuICBjb25zdCBbZXZlbnRzLCBzZXRFdmVudHNdID0gdXNlU3RhdGUoW10pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgbGV0IHVwZGF0ZTtcclxuICAgIGNvbnN0IHVwZGF0ZUZ1bmMgPSAoKSA9PiB7XHJcbiAgICAgIGdldEV2ZW50cyhwcm9wcy50aW1lTWluLCBwcm9wcy50aW1lTWF4LCBwcm9wcy5jYWxlbmRhcklELCBwcm9wcy5hcGlLZXkpXHJcbiAgICAgICAgLnRoZW4oZXZlbnRzID0+IHNldEV2ZW50cyhldmVudHMpKTtcclxuXHJcbiAgICAgIHVwZGF0ZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHVwZGF0ZUZ1bmMoKTtcclxuICAgICAgfSwgcHJvcHMudXBkYXRlVGltZSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHVwZGF0ZUZ1bmMoKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBjbGVhclRpbWVvdXQodXBkYXRlKTtcclxuICAgIH1cclxuICB9LCBbcHJvcHMudGltZU1pbiwgcHJvcHMudGltZU1heCwgcHJvcHMudXBkYXRlVGltZSwgcHJvcHMuY2FsZW5kYXJJRCwgcHJvcHMuYXBpS2V5XSk7XHJcblxyXG4gIGNvbnN0IEV2ZW50ID0gcHJvcHMuY2hpbGRyZW4gfHwgU3R1ZGVudFNjaGVkdWxlRXZlbnQ7XHJcbiAgY29uc3Qgbm9FdmVudCA9IHByb3BzLm5vRXZlbnQgfHwgQ2FsZW5kYXJOb0V2ZW50O1xyXG5cclxuICBsZXQgZXZlbnRzVG9kYXkgPSBldmVudHMuZmlsdGVyKChlKSA9PiBpc1RvZGF5VG9tb3Jyb3coZS5zdGFydC5kYXRlVGltZSkpO1xyXG4gIGlmIChwcm9wcy5saW1pdCA+PSAwKSB7XHJcbiAgICBldmVudHNUb2RheSA9IGV2ZW50c1RvZGF5LnNsaWNlKDAsIHByb3BzLmxpbWl0KTtcclxuICB9XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT0nY2FsZW5kYXItZXZlbnRzJz5cclxuICAgICAge2V2ZW50c1RvZGF5Lmxlbmd0aCA/IGV2ZW50c1RvZGF5Lm1hcCgoZSwgaSkgPT4gRXZlbnQoZSwgaSkpIDogbm9FdmVudCh0cnVlKX1cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn1cclxuXHJcblN0dWRlbnRTY2hlZHVsZS5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XHJcblN0dWRlbnRTY2hlZHVsZS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBTdHVkZW50U2NoZWR1bGU7Il19